# Exercise 1.7
## 問題
>平方根の演算で使用された good-enough? テストはとても小さい数値の平方根を見つける場合にはあまり効果的ではないだろう。また実際のコンピュータでは数値演算命令はほとんど常に精度に制限のある状態で実行される。これが我々のテストをとても大きな数値に対して不適切にする。ここまでの記述についてテストがどのように小さな値と大きな値にて失敗するか例を用いて説明せよ。good-enough? 実装の代替戦略は guess がある試行から次に向けどのように変化するか監視し、変化が推定値の割合においてとても小さい時に止めることである。このような終了テストを用いる square-root を設計せよ。これは小さな、及び、大きな数値に対してより良く働くだろうか?

## 解答
### 小さな値に対して
小さな値の sqrt を計算する場合，guess の二乗と x の誤差というのが，規定値より小さくなったとしても，x が規定値よりも小さいとその誤差は無視できなくなる．つまり，誤差の規定値は x の大きさに依存して変更されるべきであるということになる．

### 大きな値に対して
大きな値の sqrt を計算する場合，問題になるのは計算機の精度の限界である．もし精度に限界がなければ，大きな数値の場合はこの sqrt 関数で問題なく計算することができる．
例えば，
```
sqrt(10000000000000)
```
を計算する場合，
```
guess = 3162277.6601683795;
```
まで計算された時に，
```
3162277.6601683795 = improve(3162277.6601683795, 10000000000000);
```
となる．つまり，精度の制限により，これ以上 guess を improve することができない．
しかし一方で，
```
guess * guess = 10000000000000.002;
```
であり，規定値を超えることができない．
小さな値ではこの問題は起きずに，大きな値の時だけ起きる理由は，小さい値の場合の guess を見てるとわかる．
```
x = 10;
```
の時の guess は，
```
guess = 3.659090909090909;
```
となる．
つまり，x が大きい値の時には，整数部が有効桁を占有してしまい，小数部で十分な精度を確保できていないことが原因であるとわかる．

### 解決策
guess の二乗と x の誤差と規定値を比較するのではなく，guess と improveされた値を比較し，その誤差が規定値よりも小さいかどうかを監視することで，解決する．
この場合，上記で議論した小さい値の場合，大きい値の場合の両方の問題が解決される．
具体的なコードは，
```
ex1_7.js
```
を参照．
